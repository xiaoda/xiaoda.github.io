[{"title":"兼容nodejs环境的前端项目","date":"2017-10-15T07:50:02.000Z","path":"兼容nodejs环境的前端项目/","text":"math-object 是我正在开发的一个数学对象库。最初在初始化项目时，我习惯性地使用了 webpack 搭建了项目的开发环境。/public 下有一个 demo 页面，这个页面引用了项目生成的 js 库并使用其方法。有一天我突然想，既然这是一个纯粹的 js 项目，demo 页面也只是进行简单的 console.log 操作，要是能直接用 nodejs 跑起来多爽啊。OK，开始整！ 1node public/index.js 直接在命令行执行上述命令。好了，一大波问题开始接近了… 第一个问题：import 报错。nodejs 的模块化遵循的是 commonjs 规范，引入模块用 require 关键字；而 import 是 es6 的模块化规范，因此代码里的所有 import 报错了，需要替换为 require。题外话：因为一直使用 webpack 作为前端项目的构建工具，同时仅有简单的模块引入需求，所以对 import 和 require 并没有感觉到明显的不同，用哪个都差不多。但是最近有次体会到了两者的一个比较大的区别：import 必须在一开始引入模块，而 require 可以在需要的时候引入。当项目对引入模块的时机有要求时，require 显得更加灵活。 第二个问题：{…} 报错。这是 es7 的对象、数组解构赋值的内容，当前仍处于 stage 1。其实 nodejs 从 6.0 版本开始已经支持 es6 语法了，只是支持得还不够全面。前面提到的 import 就是其中之一，这次遇到的解构赋值属于 es7 内容，nodejs 不支持是再正常不过的事了。鉴于这个语法非常好用，也为了能在项目中使用更多的 es6+ 语法，我选择了 babel-node，再也不用担心语法问题，在目前的小项目中也没有发现执行速度之类的问题。 第三个问题：config / helper / util 未定义。出现问题的原因是：项目本来使用了 webpack 的 ProvidePlugin 插件，在 webpack 里配置好后，在任何文件里使用全局模块就不需要手动引入了。当项目用 nodejs 运行的时候没有 webpack 自然会出现这个问题了。在一番权衡之后我老老实实地给用到全局模块的文件手动加上了模块引用，讲道理这样确实是对的，因为使用模块前有显示的模块调用会让代码更加清楚，只是每个文件都要加显得繁琐而已。不知以后会不会有更好的解决方案。 解决了这三个问题之后，原本的一个纯前端项目就可以在 nodejs 里运行啦。开发的时候就不用打开浏览器了，甚至可以把项目放到云服务器上进行远程开发。当然用 nodejs 运行还有很多需要优化的地方，比如 console.log 的显示优化等等，待慢慢尝试和改进。","tags":[]},{"title":"资源拓扑图 milestone","date":"2017-09-30T02:13:24.000Z","path":"资源拓扑图milestone/","text":"拓扑图在常规的前端开发中很少用到，但在云计算的前端中就很重要了。拓扑图可以将云计算资源直观地展现在用户面前，使用户轻松地理清资源关系，还可以直接对看到的资源进行操作。在一番调研后发现，AWS、ServiceNow、VisualOps、青云等云计算服务商已有资源拓扑图或类似的应用。那么如何开发一个资源拓扑图项目呢？ 首先，一个资源拓扑图项目应该分为两部分。底层基础：拓扑图插件（自己开发或第三方）；上层建筑：资源拓扑图（业务所需的配置、功能）。 拓扑图插件的选择是第一个重要的决定。拓扑图插件的本质是根据 js 描述的特征生成对应的拓扑图输出到页面的 canvas 元素上，并提供必要的事件和方法。当前主要有以下拓扑图插件库： jointjs（收费）：功能强大，AWS 资源拓扑图使用的插件库 vis.js：Github 星星多，文档、案例齐全，偏底层 cytoscape.js：不错的拓扑图插件，偏底层 sigmajs：侧重于密集的点线图 gojs（收费）：多款预置的拓扑图类型，偏应用 在一番比较后，我选择了 vis.js。原因是： 开源免费库，没有使用成本和法律风险的顾虑。 文档、案例齐全，更容易上手和深入。 API 偏底层，便于调整基础样式和功能。 其实在选择拓扑图插件时也有考虑过自己开发一个拓扑图插件，好处是可以完全从项目的需求入手，满足所有要求。但这么干的问题是工作量大，无法在短期内完成；此外自己开发的拓扑图插件在初期一定会有很多 bug 需要修复，这是我们的资源拓扑图项目所不能承受的。 确定好拓扑图插件后就该搭建上层建筑了。在几周的开发之后，该项目以 jQuery 插件（Bootstrap 4 / ES 6 风格）的方式完成第一版并输出，后续会支持更多操作。","tags":[]},{"title":"精简通用的帮助方法库：xdhelper","date":"2017-06-09T03:44:11.000Z","path":"精简通用的帮助方法库：xdhelper/","text":"xdhelper 是一个 JS 帮助方法库，开发时尝试了一些新的东西： webpack 2.x 跟 webpack 1.x 相比，基础功能、配置文件变化不大，迁移方便。 flowtype 函数参数和输出的数据格式必须指定。 eslint 对 JS 格式、语法等进行严格检查，强制纠正不规范的地方。与 flowtype 配合使用需要在 eslint 配置文件里加入 flowtype 的检查方法。 mocha JS 单元测试。 npm publish 封装 npm 包并发布，方便外部调用。 travis 在 npm 和 github 项目主页显示测试和构建状况。","tags":[]},{"title":"原生js实现简单事件代理","date":"2017-02-27T16:24:27.000Z","path":"原生js实现简单事件代理/","text":"与 jQuery 的事件代理使用相同参数 区别：自定义了 delegate 函数，而非 jQuery 对象的方法 只支持传入单个 class 名 1234567891011function delegate (action, className, callback) &#123; document.addEventListener(action, function (event) &#123; if (event.target.classList.contains(className.slice(1))) &#123; callback(event) &#125; &#125;)&#125;delegate('click', '.block', function (event) &#123; console.log('事件 #代理#')&#125;) Live Demo","tags":[]},{"title":"Hello World","date":"2017-02-14T08:54:39.000Z","path":"hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]