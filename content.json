[{"title":"初试 Web Speech API","date":"2017-12-25T03:44:08.000Z","path":"初试-Web-Speech-API/","text":"不久前百度宣布语音技术全系列接口永久免费开放，近年来语音技术的应用越来越广泛。在浏览器标准方面，Web Speech API 可以使 Web App 获得语音识别和语音合成能力。当前的 Web Speech API 还是一个实验技术，Chrome 已经支持。 心得 必须 https 网站或本地 localhost 域名才能使用，file 方式访问或非 https 的自定义域名不可用。 每次调用 API 时，Chrome 会在后台访问远程的语音相关接口，因此必须保证连接全球互联网。 识别语言可选择，选择中文时可识别中英文混合语音。 识别成功后返回文字，同时返回信心值。 Live Demo","tags":[]},{"title":"浏览器缓存问题解决办法","date":"2017-12-25T02:32:48.000Z","path":"浏览器缓存问题解决办法/","text":"HTTP 缓存 | Web | Google Developers 详细解释了现代浏览器的缓存方法和策略。 缓存策略图 如希望浏览器不做任何缓存以保证访问文件的正确，必须指定 no-store。以 Nginx 为例： 123location ~ .*/.html$ &#123; add_header Cache-Control no-store;&#125; PS: 圣诞节快乐！","tags":[]},{"title":"主流前端框架简介（PPT）","date":"2017-11-29T07:53:37.000Z","path":"主流前端框架简介（PPT）/","text":"→PPT 地址← 主要内容： Web 框架比较（Angular / React / Vue） 移动端框架比较（Ionic / Cordova）","tags":[]},{"title":"脱离 webpack 的现代化前端技术栈","date":"2017-11-07T02:01:23.000Z","path":"脱离webpack的现代化前端技术栈/","text":"从去年（2016年）开始，新的前端技术如 React / ES6 等大范围地流行起来。在实际的项目里用上 React 和 ES6 不是一件容易事，因为 React 的 JSX 需要经过编译后运行；而 ES6 作为一个全新的语言标准，Chrome / Firefox 等现代浏览器只有部分支持，IE 等过时的浏览器根本没有支持的可能。再加上前端代码压缩、合并、组件化的需求，一个牛逼的构建工具应运而生，这就是 webpack！webpack 可以用来构建现代化的纯前端项目，根据模块的调用关系加载模块代码，辅以各类插件完成 React / ES6 的编译、代码压缩合并等工作。除此之外，它还提供了一个好用的本地开发环境工具 webpack-dev-server 使开发环境下运行服务器变得简单。不仅是 React / Vue 等纯前端项目，连 Laravel 等后端框架都默认使用 webpack 作为前端构建工具。 在相当长的时间里，我开发的绝大多数项目都用到了 webpack。在此期间，使用 webpack 带来的问题慢慢地出现了。 一个新项目用 webpack 搭建前端架构需要不少时间。首先文件结构要先确定下来，因为这关系到 webpack 的编译目录；正确配置 path / publicPath / contentBase 等路径；所有文件分门别类，使用对应的 loader 进行编译，每个 loader 赋予恰当参数；用 CopyWebpackPlugin 等插件完成自定义的构建需求；开发初期做好的构建配置随着后期的开发根据需要不断地进行调整。总体来看，webpack 确实为我们提供了完美的前端构建工具，但需要花费大量时间在 webpack 的配置和后期调整上。当实际项目体量小但数量多时，我们可能需要不停地创建和维护构建 webpack 配置文件，这时的我们简直成了配置工程师。因此，webpack 在大型项目中更加适用，花在配置上的时间跟它带来的强大功能、便捷开发相比是划算的；在小型项目里容易得不偿失。 那么有没有在使用前端框架、ES6 的同时，脱离 webpack 的解决方案呢？我认为：有。 首先，前端框架选择 Vue。Vue 是今年（2017年）国内最流行的前端框架，它与 React 的优缺点比较暂且不表。它有一个大部分框架所不具备的优势：Vue 可以直接通过 script 标签引入、不需要 vue-loader 就可以应用于真实的 DOM 节点。Vue 的前端框架（以 element 为例）也可以直接通过 script 标签引入后使用。这从根本上解决了纯前端项目对 webpack 的依赖。接下来是 ES6，近些年浏览器厂商在版本的更新迭代中对 ES6 的支持越来越好，Chrome / Firefox / IE Edge 对 ES6 标准的支持程度已经能达到 97% 左右，所以直接在浏览器环境中运行 ES6 已经不是问题。如果需要在旧版本浏览器运行 ES6 或者使用 Chrome 等浏览器还不支持的 ES7 语法，可以选择对应的 polyfill。脱离 webpack 意味着不能在 js 中直接用 require / import 关键字引入模块，等价的替代方案是使用 RequireJS（需要按规范重新定义模块，比较麻烦），退一步的替代方案是用 script 标签引入可以在浏览器环境直接执行的模块文件，Vue 的组件模块需要按 Vue 规定的方式输出后使用（这方面确实不完美，但在小型项目中不是大问题，期待未来有更好的方案）。 回头看前端构建的历史，webpack 的出现算得上是时势造英雄。由于当时的浏览器不支持最新的语言标准、模块引入的标准，主流前端框架必须经过编译，大量用户带宽慢如小水管，才需要开发者的兼顾和妥协。随着时间不断向前，浏览器的标准支持、前端框架的灵活程度、带宽等问题慢慢的不再是问题的时候，开发者就不再那么需要 webpack 及插件做构建了。从代码编写到浏览器显示的过程中没有多余的中间步骤，是纯粹的前端开发体验。","tags":[]},{"title":"兼容 nodejs 环境的前端项目","date":"2017-10-15T07:50:02.000Z","path":"兼容nodejs环境的前端项目/","text":"math-object 是我正在开发的一个数学对象库。最初在初始化项目时，我习惯性地使用了 webpack 搭建了项目的开发环境。/public 下有一个 demo 页面，这个页面引用了项目生成的 js 库并使用其方法。有一天我突然想，既然这是一个纯粹的 js 项目，demo 页面也只是进行简单的 console.log 操作，要是能直接用 nodejs 跑起来多爽啊。OK，开始整！ 1node public/index.js 直接在命令行执行上述命令。好了，一大波问题开始接近了… 问题一：import 报错。nodejs 的模块化遵循的是 commonjs 规范，引入模块用 require 关键字；而 import 是 es6 的模块化规范，因此代码里的所有 import 报错了，需要替换为 require。题外话：因为一直使用 webpack 作为前端项目的构建工具，同时仅有简单的模块引入需求，所以对 import 和 require 并没有感觉到明显的不同，用哪个都差不多。但是最近有次体会到了两者的一个比较大的区别：import 必须在一开始引入模块，而 require 可以在需要的时候引入。当项目对引入模块的时机有要求时，require 显得更加灵活。 问题二：{…} 报错。这是 es7 的对象、数组解构赋值的内容，当前仍处于 stage 1。其实 nodejs 从 6.0 版本开始已经支持 es6 语法了，只是支持得还不够全面。前面提到的 import 就是其中之一，这次遇到的解构赋值属于 es7 内容，nodejs 不支持是再正常不过的事了。鉴于这个语法非常好用，也为了能在项目中使用更多的 es6+ 语法，我选择了 babel-node，再也不用担心语法问题，在目前的小项目中也没有发现执行速度之类的问题。 问题三：config / helper / util 未定义。问题出现的原因是：项目本来使用了 webpack 的 ProvidePlugin 插件，在 webpack 里配置好后，在任何文件里使用全局模块就不需要手动引入了。当项目用 nodejs 运行的时候没有 webpack 自然会出现这个问题了。在一番权衡之后我老老实实地给用到全局模块的文件手动加上了模块引用，讲道理这样确实是对的，因为使用模块前有显示的模块调用会让代码更加清楚，只是每个文件都要加显得繁琐而已。不知以后会不会有更好的解决方案。 问题四：window 未定义。先前在浏览器内运行所以写了 window.C 等价于 console.log，方便打印和调试。nodejs 环境里没有全局的 window 对象，因此绑在 windows 上的属性、方法需要移除。 解决了这四个问题之后，原本的一个纯前端项目就可以在 nodejs 里运行啦。开发的时候就不用打开浏览器了，甚至可以把项目放到云服务器上进行远程开发。当然用 nodejs 运行还有很多需要优化的地方，比如 console.log 的显示优化等等，待慢慢尝试和改进。","tags":[]},{"title":"资源拓扑图 milestone","date":"2017-09-30T02:13:24.000Z","path":"资源拓扑图milestone/","text":"拓扑图在常规的前端开发中很少用到，但在云计算的前端中就很重要了。拓扑图可以将云计算资源直观地展现在用户面前，使用户轻松地理清资源关系，还可以直接对看到的资源进行操作。在一番调研后发现，AWS、ServiceNow、VisualOps、青云等云计算服务商已有资源拓扑图或类似的应用。那么如何开发一个资源拓扑图项目呢？ 首先，一个资源拓扑图项目应该分为两部分。底层基础：拓扑图插件（自己开发或第三方）；上层建筑：资源拓扑图（业务所需的配置、功能）。 拓扑图插件的选择是第一个重要的决定。拓扑图插件的本质是根据 js 描述的特征生成对应的拓扑图输出到页面的 canvas 元素上，并提供必要的事件和方法。当前主要有以下拓扑图插件库： jointjs（收费）：功能强大，AWS 资源拓扑图使用的插件库 vis.js：Github 星星多，文档、案例齐全，偏底层 cytoscape.js：不错的拓扑图插件，偏底层 sigmajs：侧重于密集的点线图 gojs（收费）：多款预置的拓扑图类型，偏应用 在一番比较后，我选择了 vis.js。原因是： 开源免费库，没有使用成本和法律风险的顾虑。 文档、案例齐全，更容易上手和深入。 API 偏底层，便于调整基础样式和功能。 其实在选择拓扑图插件时也有考虑过自己开发一个拓扑图插件，好处是可以完全从项目的需求入手，满足所有要求。但这么干的问题是工作量大，无法在短期内完成；此外自己开发的拓扑图插件在初期一定会有很多 bug 需要修复，这是我们的资源拓扑图项目所不能承受的。 确定好拓扑图插件后就该搭建上层建筑了。在几周的开发之后，该项目以 jQuery 插件（Bootstrap 4 / ES 6 风格）的方式完成第一版并输出，后续会支持更多操作。","tags":[]},{"title":"精简通用的帮助方法库：xdhelper","date":"2017-06-09T03:44:11.000Z","path":"精简通用的帮助方法库：xdhelper/","text":"xdhelper 是一个 JS 帮助方法库，开发时尝试了一些新的东西： webpack 2.x 跟 webpack 1.x 相比，基础功能、配置文件变化不大，迁移方便。 flowtype 函数参数和输出的数据格式必须指定。 eslint 对 JS 格式、语法等进行严格检查，强制纠正不规范的地方。与 flowtype 配合使用需要在 eslint 配置文件里加入 flowtype 的检查方法。 mocha JS 单元测试。 npm publish 封装 npm 包并发布，方便外部调用。 travis 在 npm 和 github 项目主页显示测试和构建状况。","tags":[]},{"title":"原生 js 实现简单事件代理","date":"2017-02-27T16:24:27.000Z","path":"原生js实现简单事件代理/","text":"与 jQuery 的事件代理使用相同参数 区别：自定义了 delegate 函数，而非 jQuery 对象的方法 只支持传入单个 class 名 1234567891011function delegate (action, className, callback) &#123; document.addEventListener(action, function (event) &#123; if (event.target.classList.contains(className.slice(1))) &#123; callback(event) &#125; &#125;)&#125;delegate('click', '.block', function (event) &#123; console.log('事件 #代理#')&#125;) Live Demo","tags":[]}]